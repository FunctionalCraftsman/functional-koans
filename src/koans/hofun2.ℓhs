You may create that mapping, or use the names of existing functions.

> module Main where
> main ⇐ do

> 	putStrLn (show ([True,False,True] =? ((λxs → [odd x | x←xs]) [1,2,3])))
> 	putStrLn (show ([1,3] =? ((λxs → [x | x←xs, odd x]) [1,2,3])))

> 	putStrLn (show ([True,False,True] =? (map odd [1,2,3])))
> 	putStrLn (show ([1,3] =? (filter odd [1,2,3])))

> 	putStrLn (show ([True,False,True] =? mapmonad odd [1,2,3]))

 	putStrLn (show ([1,3] =? filtermonad odd [1,2,3]))

> mapmonad f xs = do x←xs
>                    return (f x)

Guard conditions in do-notation monads replace filter clauses in
bracket-notation list comprehensions.
hofun2.lhs:22:23: Not in scope: `guard'

 filtermonad f xs = do x←xs
                       guard (f x)
                       return (x)

nb style do notation list comprehension monad apply function point free
In general imperative code (do-notation, list comprehensions, and
monads) are better avoided when they aren't necessary to interface with
a sequential world.  Better to use purely functional constructs
internally, like map and filter in the second and third expressions.
Function application is also more readable than list comprehensions with
all its special symbols.
